---
title: "Exploration des données"
author: Arnaud Vanholderbeke, Benjamin Loriot et Natan Danous
date: 11 Mai 2019
output:
  pdf_document:
    toc: true
  html_document: default
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = FALSE)
library(tidyverse)
library(knitr)
library(ggfortify)
library("plot3D")
library("scatterplot3d")
bf <- read.csv("dataset.csv", header=T)
```

## Description
Ces données sont les ventes provenant d'un seul magasin lors du Black Friday.
Le magasin veut mieux comprendre le comportement des consommateur sur différents produits.
Selon Kaggle, le problème principal est un problème de regression. On essaie de prédire la variable quantité d'achat à l'aide des autres variables. Ce problème peut également être vu comme un problème de régression.

## Types et granularité

```{r types_table}
types_table <- data.frame(
  Champ = c("Purchase", "User_ID", "Product_ID", "Gender", "Age", "Occupation", "City_Category", "Stay_In_Current_City_Years", "Marital_Status", "Product_Category_1", "Product_Category_2", "Product_Category_3"),
  Type = c("Quantitative", "Ordinal", "Nominal", "Nominal", "Ordinal", "Nominal", "Nominal", "Ordinal", "Nominal", "Nominal", "Nominal", "Nominal"),
  Modalités = c("", "", "", "F, M", "0-17 -> ... -> 51-55 -> 55+", "0 -> 20", "A, B, C", "0, 1, 2, 3, 4+", "0, 1", "1 -> 18", "2 -> 18 (avec NA)", "3 -> 18 (avec NA)")
)
kable(types_table, caption = "Dictionnaire des données")
```

Remarque :

- Un produit a obligatoirement une catégorie (Product_Category_1 ne contient pas de NA). Il n'a pas obligatoirement de 2ème et 3ème catégorie.

```{r types}
bf$Occupation <- factor(bf$Occupation, levels = c('0', '1', '2', '3', '4', '5', '6', '7', '8', '9', '10', '11', '12', '13', '14', '15', '16', '17', '18', '19', '20'))
bf$Marital_Status <- factor(bf$Marital_Status, levels = c('0', '1'))
bf$Product_Category_1 <- factor(bf$Product_Category_1, levels = c('1', '2', '3', '4', '5', '6', '7', '8', '9', '10', '11', '12', '13', '14', '15', '16', '17', '18'))
bf$Product_Category_2 <- factor(bf$Product_Category_2, levels = c('2', '3', '4', '5', '6', '7', '8', '9', '10', '11', '12', '13', '14', '15', '16', '17', '18'))
bf$Product_Category_3 <- factor(bf$Product_Category_3, levels = c('3', '4', '5', '6', '7', '8', '9', '10', '11', '12', '13', '14', '15', '16', '17', '18'))
```

## Distribution

### Sexe

```{r}
ggplot(data = bf) +
  geom_bar(mapping = aes(x = Gender, y = ..count.., fill = Gender)) +
  labs(title = 'Sexe des clients')
```

### Age

```{r}
ggplot(data = bf) +
  geom_bar(mapping = aes(x = Age, y = ..count.., fill = Age)) +
  labs(title = 'Age des clients')
```

La distribution de l'age dans une population suit habituellement une loi normale. On observe ici que ce n'est pas le cas. Il apparait que la tranche d'âge des 26-35 effectue le plus d'achats lors du Black Friday.

```{r}
purchase_sum = aggregate(
  bf$Purchase,
  list(User_ID = bf$User_ID, Gender = bf$Gender, City_Category = bf$City_Category, Age = bf$Age),
  sum
)

ggplot(purchase_sum, aes(x = Age, y = x, fill=Age)) +
  geom_bar(stat = "summary", fun.y = "mean") +
  labs(title = 'Dépenses total selon l\'âge')
```

### Métier

```{r}
ggplot(data = bf) +
  geom_bar(mapping = aes(x = Occupation, y = ..count.., fill = Occupation)) +
  labs(title = 'Métier des clients')
```

### Type de ville

```{r}
ggplot(data = bf) +
  geom_bar(mapping = aes(x = City_Category, y = ..count.., fill = City_Category)) +
  labs(title = 'Type de ville des clients')
```

### Ancienneté dans la ville

```{r}
ggplot(data = bf) +
  geom_bar(mapping = aes(x = Stay_In_Current_City_Years, y = ..count.., fill = Stay_In_Current_City_Years)) +
  labs(title = 'Ancienneté dans la ville des clients')
```

### Situation conjugale

```{r}
ggplot(data = bf) +
  geom_bar(mapping = aes(x = Marital_Status, y = ..count.., fill = Marital_Status)) +
  labs(title = 'Situation conjugale des clients')
```

### Catégories des produits

```{r}
ggplot(data = bf) +
  geom_bar(mapping = aes(x = Product_Category_1, y = ..count.., fill = Product_Category_1)) +
  labs(title = 'Catégorie de produit 1')
```

```{r}
ggplot(data = bf) +
  geom_bar(mapping = aes(x = Product_Category_2, y = ..count.., fill = Product_Category_2)) +
  labs(title = 'Catégorie de produit 2')
```

```{r}
ggplot(data = bf) +
  geom_bar(mapping = aes(x = Product_Category_3, y = ..count.., fill = Product_Category_3)) +
  labs(title = 'Catégorie de produit 3')
```

### Performance des produits

```{r}
bf.by_product_id <- bf %>% group_by(Product_ID) %>% summarise(Quantity = n()) %>% arrange(desc(Quantity))
ggplot(data = bf.by_product_id[1:25,], aes(x = reorder(Product_ID, -Quantity), y = Quantity)) +
  geom_bar(stat = 'identity') +
  theme_minimal() +
  theme(axis.text.x = element_text(angle = 45, vjust = 1,
                                   size = 12, hjust = 1)) +
  labs(title = 'Classement des 25 meilleurs produits selon le nombre de ventes', x = 'Product ID', y = 'Quantité vendue')
```

Le premier produit se détache du reste.

Commercial

- Performance des produit (via ID)
- Catégorie de produit qui se vendent le mieux

## Visu

```{r gender}
bf_gender = bf %>% select(User_ID, Gender) %>% group_by(User_ID) %>% distinct()
summary(bf_gender)
ggplot(data = bf) +
  geom_bar(mapping = aes(x = Age, y = ..count.., fill = Age), position=position_dodge()) +
  labs(title = 'Age and gender of Customers')
```

```{r total}
purchase_sum = aggregate(bf$Purchase,
          list(User_ID = bf$User_ID, Gender = bf$Gender, City_Category = bf$City_Category, Age = bf$Age),
          sum)

summary(purchase_sum)
ggplot(purchase_sum, aes(x = Age, y = x, fill=Age)) +
  geom_bar(stat = "summary", fun.y = "mean") +
  labs(title = 'Avg total purchase depending on the age of Customers')
```


## Mesure de l'entropie et du gain d'entropie

TODO: A expliquer et justifier et synthétiser.


```{r entropy}
library(entropy)

global_sells = bf %>%
  select(Product_ID) %>%
  group_by(Product_ID) %>%
  summarise(count=n())
global_sells_sum = sum(global_sells$count)
global_sells$prob = global_sells$count / global_sells_sum

sapply(c('Age', 'Gender', 'Stay_In_Current_City_Years', 'Occupation', 'Marital_Status', 'City_Category'), function(test){
  discriminators = levels(bf[,test])
  sells_city = sapply(discriminators, function(category){
    sells = bf[bf[,test] == category,] %>%
      select(Product_ID) %>%
      group_by(Product_ID) %>%
      summarise(count=n())
    s <- sum(sells$count)
    sells$prob = sells$count / sum(sells$count)
    return(list(prob=sells$prob, sum=s))
  })

  entropy_sum <- function(acc,cur) {
    acc + entropy(sells_city[,cur]$prob) *  sells_city[, cur]$sum / global_sells_sum #
  }

  entropy_gain = entropy(global_sells$prob) - Reduce(entropy_sum, discriminators, 0)
  entropy_gain
})
```

Deux catégories importantes : Age et Occupation.

## Embedding des client (+ clustering)

```{r}
categories =  c('1', '2', '3', '4', '5', '6', '7', '8', '9', '10', '11', '12', '13', '14', '15', '16', '17', '18')
user_pc <- sapply(unique(bf$User_ID), function(user){
  user_data <- bf[bf$User_ID == user,]
  cat_count <- matrix(0, length(categories), 1, dimnames = list(categories, c(user)))
  #print(as.numeric(rownames(user_data)))
  for (line in as.numeric(rownames(user_data))){
    PC_1 <- as.numeric(bf[line,]$Product_Category_1)
    cat_count[PC_1] <- cat_count[PC_1] + 1
    if (! is.na(bf[line,]$Product_Category_2)){
      PC_2 <- as.numeric(bf[line,]$Product_Category_2)
      cat_count[PC_2] <- cat_count[PC_2] + 1
    }
    if (! is.na(bf[line,]$Product_Category_3)){
      PC_3 <- as.numeric(bf[line,]$Product_Category_3)
      cat_count[PC_3] <- cat_count[PC_3] + 1
    }
  }
  #cat_count[length(categories) + 1] = user
  cat_count
})
```
```{r}
X <- bf %>% group_by(User_ID, Product_Category_1) %>% summarise(Purchase = sum(Purchase)) %>% spread(key = Product_Category_1, value = Purchase, fill = 0)
# Remove User_ID
X <- X[,-1]
# Scale
#X <- scale(X, T, T)
```

```{r}
  colnames(user_pc) <- unique(bf$User_ID)
  rownames(user_pc) <- as.numeric(categories)
  user_pc_df <- as.data.frame(t(user_pc)[, 1:18])
  n_user_pc_df <- t(apply(user_pc_df, MARGIN = 1, function(row){
    return(row / sqrt(sum(row*row)))
  }))
```

```{r}
  ages = bf %>%
    group_by(User_ID,Age, Gender, Occupation,City_Category, Marital_Status) %>%
    summarise(count=n())
  user_pc_kmeans <- kmeans(n_user_pc_df, centers = 5, nstart = 100)
  #
  r_df <- n_user_pc_df[1:1000,]
  autoplot(kmeans(r_df, centers = 5, nstart = 100), data = r_df, shape = as.factor(ages$Gender[1:1000]))
  acp.r <- prcomp(n_user_pc_df)
  scatterplot3d(acp.r$x[,1:3], pch = as.numeric(ages$Age), color = as.factor(user_pc_kmeans$cluster),
              grid=TRUE, box=TRUE, angle=55)
ages$Cluster = user_pc_kmeans$cluster
  #scatter3D(acp.r$x[,1],acp.r$x[,2],acp.r$x[,3],
  #          col.var = as.integer(user_pc_kmeans$cluster),
  #          col = c("#1B9E77", "#D95F02", "#7570B3"))
ggplot(data = ages) +
  geom_bar(mapping = aes(x = Age, y = ..count.., fill=cluster), position=position_dodge()) +
  labs(title = 'Age des clients')
ggplot(data = ages) +
  geom_bar(mapping = aes(x = Occupation, y = ..count.., fill = as.factor(Cluster)), position=position_dodge()) +
  labs(title = 'Age and gender of Customers')


```
